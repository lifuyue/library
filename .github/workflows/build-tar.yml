name: Build frontend & backend Docker images (amd64) and export docker-tars

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image version tag, e.g. v1.2.3"
        type: string
        required: true
        default: "v1.0.0"

permissions:
  contents: read
  packages: write

concurrency:
  group: build-tar-${{ github.ref }}-${{ inputs.image_tag }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  build-export:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: backend
            context: backend
            dockerfile_prod: backend/Dockerfile.prod
            image_name: myapp-backend
          - service: frontend
            context: frontend
            dockerfile_prod: frontend/Dockerfile.prod
            image_name: myapp-frontend
          - service: postgres
            context: postgres
            dockerfile_prod: postgres/Dockerfile
            image_name: myapp-postgres
    env:
      PLATFORM: linux/amd64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set DATABASE_URL for backend
        run: echo "DATABASE_URL=postgresql+psycopg://csuser:change_me@postgresql:5432/cslibrary" >> $GITHUB_ENV

      - name: Set variables
        run: |
          OWNER_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          IMAGE_TAG="$(echo "${{ inputs.image_tag }}" | tr '[:upper:]' '[:lower:]')"
          echo "OWNER_LC=$OWNER_LC" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          DF="${{ matrix.dockerfile_prod }}"
          echo "DOCKERFILE=$DF" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ matrix.image_name }}" >> $GITHUB_ENV
          echo "SERVICE=${{ matrix.service }}" >> $GITHUB_ENV
          SAFE_IMAGE_TAG=$(echo "$IMAGE_TAG" | tr '/' '-')
          echo "SAFE_IMAGE_TAG=$SAFE_IMAGE_TAG" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          USERNAME="${GHCR_USERNAME:-$GITHUB_ACTOR}"
          PASSWORD="${GHCR_TOKEN:-$GITHUB_TOKEN}"
          echo "$PASSWORD" | docker login ghcr.io -u "$USERNAME" --password-stdin

      - name: Build ${{ matrix.service }} and export docker-tar
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          ARGS=""
          if [ "$SERVICE" = "frontend" ]; then
            ARGS="--build-arg VITE_API_BASE=/api"
          fi
          docker buildx build "${{ matrix.context }}" \
            -f "$DOCKERFILE" \
            --platform "$PLATFORM" \
            --tag "$IMAGE_NAME:$IMAGE_TAG" \
            $ARGS \
            --output "type=docker,dest=${OUT_BASENAME}.tar"
          echo "Built image: $IMAGE_NAME:$IMAGE_TAG -> ${OUT_BASENAME}.tar"
          ls -lh "${OUT_BASENAME}.tar"

      - name: Push image to GitHub Container Registry
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          docker load -i "${OUT_BASENAME}.tar"
          if [ "$SERVICE" = "frontend" ]; then
            CMD=$(docker inspect -f '{{json .Config.Cmd}}' "$IMAGE_NAME:$IMAGE_TAG")
            ENTRYPOINT=$(docker inspect -f '{{json .Config.Entrypoint}}' "$IMAGE_NAME:$IMAGE_TAG")
            if echo "$CMD $ENTRYPOINT" | grep -qiE 'npm run dev|vite'; then
              echo "[ERROR] frontend image contains dev command" >&2
              exit 1
            fi
            if [ "$CMD" != '["nginx","-g","daemon off;"]' ]; then
              echo "[ERROR] unexpected frontend CMD: $CMD" >&2
              exit 1
            fi
            docker run --rm "$IMAGE_NAME:$IMAGE_TAG" sh -c "test -f /etc/nginx/nginx.conf && test -f /usr/share/nginx/html/index.html"
          fi
          docker tag "$IMAGE_NAME:$IMAGE_TAG" "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"
          docker push "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"

      - name: Compress & checksum
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          echo "$IMAGE_NAME:$IMAGE_TAG" > "${OUT_BASENAME}.images.txt"
          gzip -9 "${OUT_BASENAME}.tar"
          sha256sum "${OUT_BASENAME}.tar.gz" > "${OUT_BASENAME}.tar.gz.sha256"
          ls -lh "${OUT_BASENAME}.tar.gz"
          cat "${OUT_BASENAME}.tar.gz.sha256"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SERVICE }}-${{ env.SAFE_IMAGE_TAG }}-amd64
          path: |
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz.sha256
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.images.txt
          if-no-files-found: error
          retention-days: 7

  summary:
    needs: build-export
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          echo "Services: backend, frontend, postgres" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ inputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "Frontend built from frontend/Dockerfile.prod with VITE_API_BASE=/api" >> $GITHUB_STEP_SUMMARY

  deploy:
    needs: build-export
    runs-on: ubuntu-latest
    env:
      OWNER_LC: ${{ github.repository_owner }}
      IMAGE_TAG: ${{ inputs.image_tag }}
    steps:
      - name: Log in to GHCR
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          USERNAME="${GHCR_USERNAME:-$GITHUB_ACTOR}"
          PASSWORD="${GHCR_TOKEN:-$GITHUB_TOKEN}"
          echo "$PASSWORD" | docker login ghcr.io -u "$USERNAME" --password-stdin
      - name: Pull images from GitHub Container Registry
        run: |
          docker pull ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG
      - name: Run containers with shared network
        run: |
          docker network create app-net || true
          docker run -d --name cslibrary-postgres --network app-net --network-alias postgresql \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            -e POSTGRES_DB=cslibrary -e POSTGRES_USER=csuser -e POSTGRES_PASSWORD=change_me \
            ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG \
            -c log_destination=stderr -c logging_collector=off -c log_min_messages=debug1 -c log_statement=all -c client_min_messages=log

          docker run -d --name cslibrary-backend --network app-net \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            -e DATABASE_URL=postgresql+psycopg://csuser:change_me@postgresql:5432/cslibrary \
            --network-alias backend \
            ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG

          docker run -d --name cslibrary-frontend --network app-net \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG

      - name: Wait frontend container running (up to 30s)
        run: |
          i=0
          until [ "$(docker inspect -f '{{.State.Running}}' cslibrary-frontend 2>/dev/null || echo false)" = "true" ]; do
            i=$((i+1))
            if [ $i -ge 15 ]; then
              echo "Container cslibrary-frontend not running after ~30s"
              docker ps -a || true
              docker inspect cslibrary-frontend || true
              docker logs --tail 200 cslibrary-frontend || true
              exit 1
            fi
            echo "Waiting for cslibrary-frontend to be running... ($i/15)"
            sleep 2
          done
          echo "[OK] cslibrary-frontend is running"

      - name: Probe frontend container (wait up to 60s)
        run: |
          docker exec cslibrary-frontend sh -lc '
            which curl || apk add --no-cache curl >/dev/null 2>&1 || true
            i=0
            while [ $i -lt 30 ]; do
              echo "--- iteration $((i+1)) ---"
              echo "[ps]"; ps aux || true
              echo "[sockets]"; (command -v ss >/dev/null 2>&1 && ss -lntp) || (command -v netstat >/dev/null 2>&1 && netstat -tlnp) || true
              code_root=$(curl -fsS -o /dev/null -w "%{http_code}" http://localhost/ || true)
              code_api=$(curl -fsS -o /dev/null -w "%{http_code}" http://localhost/api/healthz || true)
              echo "[curl] GET / -> code=${code_root:-N/A}"
              echo "[curl] GET /api/healthz -> code=${code_api:-N/A}"
              if [ "$code_root" = "200" ] && [ -f /usr/share/nginx/html/index.html ] && [ "$code_api" = "200" ]; then
                echo "[OK] frontend ready"
                exit 0
              fi
              echo "Waiting for frontend... ($((i+1))/30) root=${code_root:-N/A} api=${code_api:-N/A}"
              i=$((i+1))
              sleep 2
            done
            echo "Frontend not ready after ~60s"
            echo "--- nginx -T (head) ---"; nginx -T 2>&1 | sed -n "1,200p" || true
            echo "--- html dir ---"; ls -lah /usr/share/nginx/html/ || true
            echo "--- index.html head ---"; [ -f /usr/share/nginx/html/index.html ] && head -n 20 /usr/share/nginx/html/index.html || true
            echo "--- nginx error.log (tail 200) ---"; [ -f /var/log/nginx/error.log ] && tail -n 200 /var/log/nginx/error.log || true
            exit 1
          '

      

      - name: Warm up and show container logs
        if: always()
        run: |
          sleep 5
          echo "== docker ps =="
          docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}'
          echo
          echo "== postgres logs =="
          docker logs --tail 200 cslibrary-postgres || true
          echo
          echo "== backend env & logs =="
          docker inspect -f '{{json .Config.Env}}' cslibrary-backend | jq . || true
          docker logs --tail 200 cslibrary-backend || true
          echo
          echo "== frontend logs =="
          docker logs --tail 200 cslibrary-frontend || true
 