name: Build frontend & backend Docker images (amd64) and export docker-tars

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image version tag, e.g. v1.2.3"
        type: string
        required: true
        default: "v1.0.0"

permissions:
  contents: read
  packages: write

concurrency:
  group: build-tar-${{ github.ref }}-${{ inputs.image_tag }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  build-export:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: backend
            context: backend
            dockerfile_prod: backend/Dockerfile.prod
            image_name: myapp-backend
          - service: frontend
            context: frontend
            dockerfile_prod: frontend/Dockerfile.prod
            image_name: myapp-frontend
          - service: postgres
            context: postgres
            dockerfile_prod: postgres/Dockerfile
            image_name: myapp-postgres
    env:
      PLATFORM: linux/amd64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set DATABASE_URL for backend
        run: echo "DATABASE_URL=postgresql+psycopg2://csuser:change_me@postgresql:5432/cslibrary" >> $GITHUB_ENV

      - name: Set variables
        run: |
          OWNER_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          IMAGE_TAG="$(echo "${{ inputs.image_tag }}" | tr '[:upper:]' '[:lower:]')"
          echo "OWNER_LC=$OWNER_LC" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          DF="${{ matrix.dockerfile_prod }}"
          echo "DOCKERFILE=$DF" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ matrix.image_name }}" >> $GITHUB_ENV
          echo "SERVICE=${{ matrix.service }}" >> $GITHUB_ENV
          SAFE_IMAGE_TAG=$(echo "$IMAGE_TAG" | tr '/' '-')
          echo "SAFE_IMAGE_TAG=$SAFE_IMAGE_TAG" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build ${{ matrix.service }} and export docker-tar
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          ARGS=""
          if [ "$SERVICE" = "frontend" ]; then
            ARGS="--build-arg VITE_API_BASE=/api"
          fi
          docker buildx build "${{ matrix.context }}" \
            -f "$DOCKERFILE" \
            --platform "$PLATFORM" \
            --tag "$IMAGE_NAME:$IMAGE_TAG" \
            $ARGS \
            --output "type=docker,dest=${OUT_BASENAME}.tar"
          echo "Built image: $IMAGE_NAME:$IMAGE_TAG -> ${OUT_BASENAME}.tar"
          ls -lh "${OUT_BASENAME}.tar"

      - name: GHCR preflight connectivity check (retry)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 1
          max_attempts: 4
          retry_on: error
          command: |
            curl -fsS -m 5 -I https://ghcr.io/v2/ | sed -n '1,3p'

      - name: Login to GHCR (retry up to 5)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 2
          max_attempts: 5
          retry_on: error
          command: |
            echo "${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}" | \
            docker login ghcr.io -u "${{ secrets.GHCR_USERNAME || github.actor }}" --password-stdin

      - name: Push image to GitHub Container Registry
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          docker load -i "${OUT_BASENAME}.tar"
          if [ "$SERVICE" = "frontend" ]; then
            CMD=$(docker inspect -f '{{json .Config.Cmd}}' "$IMAGE_NAME:$IMAGE_TAG")
            ENTRYPOINT=$(docker inspect -f '{{json .Config.Entrypoint}}' "$IMAGE_NAME:$IMAGE_TAG")
            if echo "$CMD $ENTRYPOINT" | grep -qiE 'npm run dev|vite'; then
              echo "[ERROR] frontend image contains dev command" >&2
              exit 1
            fi
            if [ "$CMD" != '["nginx","-g","daemon off;"]' ]; then
              echo "[ERROR] unexpected frontend CMD: $CMD" >&2
              exit 1
            fi
            docker run --rm "$IMAGE_NAME:$IMAGE_TAG" sh -c "test -f /etc/nginx/nginx.conf && test -f /usr/share/nginx/html/index.html"
          fi
          docker tag "$IMAGE_NAME:$IMAGE_TAG" "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"
          docker push "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"

      - name: Compress & checksum
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          echo "$IMAGE_NAME:$IMAGE_TAG" > "${OUT_BASENAME}.images.txt"
          gzip -9 "${OUT_BASENAME}.tar"
          sha256sum "${OUT_BASENAME}.tar.gz" > "${OUT_BASENAME}.tar.gz.sha256"
          ls -lh "${OUT_BASENAME}.tar.gz"
          cat "${OUT_BASENAME}.tar.gz.sha256"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SERVICE }}-${{ env.SAFE_IMAGE_TAG }}-amd64
          path: |
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz.sha256
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.images.txt
          if-no-files-found: error
          retention-days: 7

  summary:
    needs: build-export
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          echo "Services: backend, frontend, postgres" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ inputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "Frontend built from frontend/Dockerfile.prod with VITE_API_BASE=/api" >> $GITHUB_STEP_SUMMARY

  deploy:
    needs: build-export
    runs-on: ubuntu-latest
    env:
      OWNER_LC: ${{ github.repository_owner }}
      IMAGE_TAG: ${{ inputs.image_tag }}
    steps:
      - name: GHCR preflight connectivity check (retry)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 1
          max_attempts: 4
          retry_on: error
          command: |
            curl -fsS -m 5 -I https://ghcr.io/v2/ | sed -n '1,3p'

      - name: Login to GHCR (retry up to 5)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 2
          max_attempts: 5
          retry_on: error
          command: |
            echo "${{ secrets.GHCR_TOKEN || secrets.GITHUB_TOKEN }}" | \
            docker login ghcr.io -u "${{ secrets.GHCR_USERNAME || github.actor }}" --password-stdin

      - name: Pull images from GitHub Container Registry
        run: |
          docker pull ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG
      - name: Create network and start postgres
        run: |
          docker network create app-net || true
          docker run -d --name cslibrary-postgres --network app-net --network-alias postgresql \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            -e POSTGRES_DB=cslibrary -e POSTGRES_USER=csuser -e POSTGRES_PASSWORD=change_me \
            ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG \
            -c log_destination=stderr -c logging_collector=off -c log_min_messages=debug1 -c log_statement=all -c client_min_messages=log

      - name: Wait for postgres ready (pg_isready, up to 60s)
        run: |
          i=0
          until docker exec cslibrary-postgres sh -lc "pg_isready -q -h localhost -p 5432 -U csuser"; do
            i=$((i+1))
            if [ $i -ge 30 ]; then
              echo "Postgres not ready after ~60s" >&2
              echo "== docker ps =="; docker ps -a || true
              echo "== postgres logs (tail 200) =="; docker logs --tail 200 cslibrary-postgres || true
              exit 1
            fi
            echo "Waiting for Postgres... ($i/30)"
            sleep 2
          done
          echo "[OK] Postgres is ready"

      - name: Start backend
        run: |
          docker run -d --name cslibrary-backend --network app-net \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            -e DATABASE_URL=postgresql+psycopg2://csuser:change_me@postgresql:5432/cslibrary \
            --network-alias backend \
            ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG

      - name: Wait for backend healthz (up to 60s)
        run: |
          i=0
          while [ $i -lt 30 ]; do
            code=$(docker exec cslibrary-backend sh -lc "curl -fsS -o /dev/null -w '%{http_code}' http://localhost:8000/healthz || true")
            if [ "$code" = "200" ]; then
              echo "[OK] Backend /healthz 200"
              break
            fi
            i=$((i+1))
            echo "Waiting for backend... ($i/30) code=${code:-N/A}"
            sleep 2
          done
          if [ $i -ge 30 ]; then
            echo "Backend not ready after ~60s" >&2
            echo "== backend ps =="; docker exec cslibrary-backend sh -lc "ps -ef | sed -n '1,200p'" || true
            echo "== backend sockets =="; docker exec cslibrary-backend sh -lc "(command -v ss >/dev/null 2>&1 && ss -ltnp) || (command -v netstat >/dev/null 2>&1 && netstat -tlnp) || true" || true
            echo "== backend logs (tail 200) =="; docker logs --tail 200 cslibrary-backend || true
            exit 1
          fi

      - name: Start frontend
        run: |
          docker run -d --name cslibrary-frontend --network app-net \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG

      - name: Wait frontend container running (up to 30s)
        run: |
          i=0
          until [ "$(docker inspect -f '{{.State.Running}}' cslibrary-frontend 2>/dev/null || echo false)" = "true" ]; do
            i=$((i+1))
            if [ $i -ge 15 ]; then
              echo "Container cslibrary-frontend not running after ~30s"
              docker ps -a || true
              docker inspect cslibrary-frontend || true
              docker logs --tail 200 cslibrary-frontend || true
              exit 1
            fi
            echo "Waiting for cslibrary-frontend to be running... ($i/15)"
            sleep 2
          done
          echo "[OK] cslibrary-frontend is running"

      - name: Probe frontend container (static first, then API; up to 120s)
        run: |
          # Two-phase probe: A) static index, B) /api/healthz via Nginx
          # If A passes but B fails, print backend diagnostics and continue retrying.
          i=0
          while [ $i -lt 60 ]; do
            echo "--- probe iteration $((i+1))/60 ---"
            code_root=$(docker exec cslibrary-frontend sh -lc "which curl >/dev/null 2>&1 || apk add --no-cache curl >/dev/null 2>&1 || true; curl -fsS -o /dev/null -w '%{http_code}' http://localhost/ || true")
            has_index=$(docker exec cslibrary-frontend sh -lc "[ -f /usr/share/nginx/html/index.html ] && echo yes || echo no")
            code_api=$(docker exec cslibrary-frontend sh -lc "curl -fsS -o /dev/null -w '%{http_code}' http://localhost/api/healthz || true")
            echo "[A] / -> ${code_root:-N/A}, index=${has_index}"
            echo "[B] /api/healthz -> ${code_api:-N/A}"

            if [ "$code_root" = "200" ] && [ "$has_index" = "yes" ] && [ "$code_api" = "200" ]; then
              echo "[OK] Frontend static and API proxy healthy"
              exit 0
            fi

            if [ "$code_root" = "200" ] && [ "$has_index" = "yes" ] && [ "$code_api" != "200" ]; then
              echo "[WARN] Frontend OK but backend not ready/unreachable (api=${code_api:-N/A})"
              echo "== docker ps =="; docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}' || true
              echo "== backend logs (tail 120) =="; docker logs --tail 120 cslibrary-backend || true
              echo "== backend processes =="; docker exec cslibrary-backend sh -lc "ps -ef | grep -E 'gunicorn|uvicorn' | grep -v grep || true" || true
              echo "== backend sockets =="; docker exec cslibrary-backend sh -lc "(command -v ss >/dev/null 2>&1 && ss -ltnp) || (command -v netstat >/dev/null 2>&1 && netstat -tlnp) || true" || true
            else
              echo "[INFO] Frontend not ready yet (static=${code_root:-N/A}, index=${has_index})"
              # On frontend-side failure, collect targeted nginx diagnostics for clarity
              echo "--- nginx -T (head) ---"; docker exec cslibrary-frontend sh -lc "nginx -T 2>&1 | sed -n '1,120p'" || true
              echo "--- html dir ---"; docker exec cslibrary-frontend ls -lah /usr/share/nginx/html/ || true
            fi

            i=$((i+1))
            sleep 2
          done
          echo "[ERROR] Frontend probe timed out after ~120s"
          echo "--- nginx error.log (tail 200) ---"; docker exec cslibrary-frontend sh -lc "[ -f /var/log/nginx/error.log ] && tail -n 200 /var/log/nginx/error.log || true" || true
          exit 1

      

      - name: Warm up and show container logs
        if: always()
        run: |
          sleep 5
          echo "== docker ps =="
          docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}'
          echo
          echo "== postgres logs =="
          docker logs --tail 200 cslibrary-postgres || true
          echo
          echo "== backend env & logs =="
          docker inspect -f '{{json .Config.Env}}' cslibrary-backend | jq . || true
          docker logs --tail 200 cslibrary-backend || true
          echo
          echo "== frontend logs =="
          docker logs --tail 200 cslibrary-frontend || true
 
