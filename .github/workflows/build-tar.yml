name: Build frontend & backend Docker images (amd64) and export docker-tars

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image version tag, e.g. v1.2.3"
        type: string
        required: true
        default: "v1.0.0"
      prod_build:
        description: "Use production Dockerfiles (true) or dev (false)"
        type: boolean
        required: false
        default: true

permissions:
  contents: read
  packages: write

concurrency:
  group: build-tar-${{ github.ref }}-${{ inputs.image_tag }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  build-export:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: backend
            context: backend
            dockerfile_prod: backend/Dockerfile.prod
            dockerfile_dev: backend/Dockerfile.dev
            image_name: myapp-backend
          - service: frontend
            context: frontend
            dockerfile_prod: frontend/Dockerfile.prod
            dockerfile_dev: frontend/Dockerfile.dev
            image_name: myapp-frontend
          - service: postgres
            context: postgres
            dockerfile_prod: postgres/Dockerfile
            dockerfile_dev: postgres/Dockerfile
            image_name: myapp-postgres
    env:
      PLATFORM: linux/amd64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set DATABASE_URL for backend
        run: echo "DATABASE_URL=postgresql+psycopg://csuser:change_me@postgresql:5432/cslibrary" >> $GITHUB_ENV

      - name: Set variables
        run: |
          OWNER_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          IMAGE_TAG="$(echo "${{ inputs.image_tag }}" | tr '[:upper:]' '[:lower:]')"
          echo "OWNER_LC=$OWNER_LC" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          if [ "${{ inputs.prod_build }}" = "true" ]; then
            if [ "${{ matrix.service }}" = "frontend" ]; then
              echo "[warn] frontend prod build requested but production Dockerfile lacks devDependencies -> fallback to dev" >&2
              DF="${{ matrix.dockerfile_dev }}"
            else
              DF="${{ matrix.dockerfile_prod }}"
            fi
          else
            DF="${{ matrix.dockerfile_dev }}"
          fi
          echo "DOCKERFILE=$DF" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ matrix.image_name }}" >> $GITHUB_ENV
          echo "SERVICE=${{ matrix.service }}" >> $GITHUB_ENV
          SAFE_IMAGE_TAG=$(echo "$IMAGE_TAG" | tr '/' '-')
          echo "SAFE_IMAGE_TAG=$SAFE_IMAGE_TAG" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          USERNAME="${GHCR_USERNAME:-$GITHUB_ACTOR}"
          PASSWORD="${GHCR_TOKEN:-$GITHUB_TOKEN}"
          echo "$PASSWORD" | docker login ghcr.io -u "$USERNAME" --password-stdin

      - name: Build ${{ matrix.service }} and export docker-tar
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          docker buildx build "${{ matrix.context }}" \
            -f "$DOCKERFILE" \
            --platform "$PLATFORM" \
            --tag "$IMAGE_NAME:$IMAGE_TAG" \
            --output "type=docker,dest=${OUT_BASENAME}.tar"
          echo "Built image: $IMAGE_NAME:$IMAGE_TAG -> ${OUT_BASENAME}.tar"
          ls -lh "${OUT_BASENAME}.tar"

      - name: Push image to GitHub Container Registry
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          docker load -i "${OUT_BASENAME}.tar"
          docker tag "$IMAGE_NAME:$IMAGE_TAG" "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"
          docker push "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"

      - name: Compress & checksum
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          echo "$IMAGE_NAME:$IMAGE_TAG" > "${OUT_BASENAME}.images.txt"
          gzip -9 "${OUT_BASENAME}.tar"
          sha256sum "${OUT_BASENAME}.tar.gz" > "${OUT_BASENAME}.tar.gz.sha256"
          ls -lh "${OUT_BASENAME}.tar.gz"
          cat "${OUT_BASENAME}.tar.gz.sha256"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SERVICE }}-${{ env.SAFE_IMAGE_TAG }}-amd64
          path: |
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz.sha256
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.images.txt
          if-no-files-found: error
          retention-days: 7

  summary:
    needs: build-export
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          echo "Services: backend, frontend, postgres" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ inputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "prod_build: ${{ inputs.prod_build }}" >> $GITHUB_STEP_SUMMARY
          echo "Note: frontend may fallback to dev Dockerfile if prod lacks dev deps." >> $GITHUB_STEP_SUMMARY

  deploy:
    needs: build-export
    runs-on: ubuntu-latest
    env:
      OWNER_LC: ${{ github.repository_owner }}
      IMAGE_TAG: ${{ inputs.image_tag }}
    steps:
      - name: Log in to GHCR
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          USERNAME="${GHCR_USERNAME:-$GITHUB_ACTOR}"
          PASSWORD="${GHCR_TOKEN:-$GITHUB_TOKEN}"
          echo "$PASSWORD" | docker login ghcr.io -u "$USERNAME" --password-stdin
      - name: Pull images from GitHub Container Registry
        run: |
          docker pull ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG
      - name: Run containers with shared network
        run: |
          docker network create app-net || true
          docker run -d --name cslibrary-postgres --network app-net --network-alias postgresql \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            -e POSTGRES_DB=cslibrary -e POSTGRES_USER=csuser -e POSTGRES_PASSWORD=change_me \
            ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG \
            -c log_destination=stderr -c logging_collector=off -c log_min_messages=debug1 -c log_statement=all -c client_min_messages=log

          docker run -d --name cslibrary-backend --network app-net \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            -e DATABASE_URL=postgresql+psycopg://csuser:change_me@postgresql:5432/cslibrary \
            ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG

          docker run -d --name cslibrary-frontend --network app-net \
            --restart unless-stopped \
            --log-driver json-file --log-opt max-size=10m --log-opt max-file=3 \
            ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG

      - name: Warm up and show container logs
        if: always()
        run: |
          sleep 5
          echo "== docker ps =="
          docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}'
          echo
          echo "== postgres logs =="
          docker logs --tail 200 cslibrary-postgres || true
          echo
          echo "== backend env & logs =="
          docker inspect -f '{{json .Config.Env}}' cslibrary-backend | jq . || true
          docker logs --tail 200 cslibrary-backend || true
          echo
          echo "== frontend logs =="
          docker logs --tail 200 cslibrary-frontend || true
 